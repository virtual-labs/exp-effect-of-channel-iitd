<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
	<script src="https://cdn.tailwindcss.com"></script>
    <script src="https://cdn.plot.ly/plotly-latest.min.js"></script>
	<title>Virtual Labs</title>
    <style>
        .container {
            display: flex;
			  /*  height: 100vh;  Full viewport height */
    /* width: 100vw;  Full viewport width */
        }
		.left-half {
            width: 50%;
            margin-left: 60px;
			}
        .middle {
		position: relative;
		overflow: auto;
            width: 50%;
        }
        .right-half {

            width: 15%;
        }
		.right-half-ext {
		            width: 15%;
		}
        table {
            width: auto;
            border-collapse: collapse;
            margin-top: 0px;
        }
        th,
        td {
            border: 1px solid black;
            padding: 2px;
            text-align: center;
        }
        th {
            width: auto;
        }
    </style>
</head>
<body>
    <div id = "instructions">
        <h1>Instructions for QPSK Simulation (with AWGN + Rayleigh)</h1>
    <ul>
      <li class="step step4"><strong>Note:</strong> Use the input fields to enter the Number of Bits, SNR (in dB), number of multi-paths, excess delay (in ms), bit rate (in bps), symbol duration (in ms / cs), and the carrier frequency (in Hz)</li>

        <li class="step step1"><strong>Step 1:</strong> Click <em>'Generate QPSK Message'</em> to generate the input QPSK modulated signal</li>
        <li class="step step2"><strong>Step 2:</strong> Click <em>'Generate Multi-path for Rayleigh'</em> to plot the Channel Impulse Response (CIR) for the Rayleigh fading channel</li>
        <li class="step step3"><strong>Step 3:</strong> Click <em>'LTI Output'</em> to generate the output after convolution with the channel</li>        
        <li class="step step2"><strong>Step 4:</strong> Click <em>'ADD AWGN Noise'</em> to add AWGN noise</li>            

        <li class="step step1"><strong>Step 5:</strong> Click <em>'Plot BER vs SNR'</em> to compare BER with and without Rayleigh fading</li>
    </ul>
    </div>
    <br/>
    <div  style = "margin-left: 30px;">
    <h1>QPSK Simulation (with AWGN + Rayleigh)</h1>
	<br/>
    <label for="numBits" class="custom-text">Number of Bits:</label>
    <input type="number" id="numBits" value="1000"><br>

    <label for="snr" class="custom-text">Enter SNR value in dB:</label>
    <input type="number" id="snr" value="0"><br>

    <label for="numTaps" class="custom-text">Enter the number of Multi-paths:</label>
    <input type="number" id="numTaps" min = "1" value="4"><br>

    <div class="flex items-center space-x-4">
        <!-- Excess Delay Label and Input -->
        <label for="excessDelay" class="custom-text">Excess Delay:</label>
        <input type="number" id="excessDelay" value="3" readonly class="p-2 border border-gray-300 rounded-md w-24">

        <!-- Time Unit Label and Select Dropdown -->
        <label for="unit" class="custom-text">Choose time unit:</label>
        <select id="unit" class="p-2 border border-gray-300 rounded-md">
            <option value="cs">Centiseconds (cs)</option>
            <option value="ms">Milliseconds (ms)</option>
        </select>
    </div>
    
    <label for="bitRate" class="custom-text">Bit Rate (bps):</label>
    <input type="number" id="bitRate" value="100" readonly><br/>
	
    <label for="symbolDuration" class="custom-text">Symbol duration (ms):</label>
    <input type="number" id="symbolDuration" value="10" readonly>

    <br/><label for="carrierFrequency" class="custom-text">Carrier Frequency (Hz):</label>
    <input type="number" id="carrierFrequency" value="1000"><br>
    </div>
	<br>
<br/>



<div class="container">
    <div class="left-half relative">
	            <br/><br/>
                <div class="w-[450px]">
                  <img
                    src="rayleighfading.png"
                    alt="Rayleigh Fading"
					style="width: 450px; height: 400px; position: relative; left: 35px"
                  />

                <button
                  class="button bg-blue-500 text-white rounded-md px-2 py-1 absolute top-[110px] left-[-20px]"
                  onclick="runSimulation1()"
                >
                  Generate QPSK <br/> Message
                </button>
<!---				
				<button
                  class="button bg-blue-500 text-white rounded-md px-2 py-1 absolute top-[150px] left-[-20px]"
                  onclick="generateCarrierSignal()"
                >
                  Generate Carrier
                </button>
            
				<button
                  class="button bg-blue-500 text-white rounded-md px-2 py-1 absolute top-[300px] left-[-20px]"
                  onclick="generateASKModulatedSignal()"
                >
                  Generate BASK<br/>of Message
                </button>
-->
				<button
                  class="button bg-blue-500 text-white rounded-md px-2 py-1 absolute top-[440px] left-[130px]"
                  onclick="generateChannelImpulseResponse()"
                >
                Generate Multi-path for Rayleigh
                </button>
				<button
                  class="button bg-blue-500 text-white rounded-md px-2 py-1 absolute top-[480px] left-[240px]"
                  onclick="generateNoisySignalff()"
                >
                  Add AWGN Noise
                </button>
<!--					
				<button
                  class="button bg-blue-500 text-white rounded-md px-2 py-1 relative bottom-[180px] left-[400px]"
                  onclick="generateDemodulatedSignal()"
                >
                  Demodulated Signal
                </button>
				<button
                  class="button bg-blue-500 text-white rounded-md px-2 py-1 relative bottom-[120px] left-[235px]"
                  onclick="withoutRayleigh()"
                >
                Demodulated Signal<br/>without Rayleigh
                </button>
-->
                <a href = "./Effect_of_channel_bpsk_ber.html">
                <button
                  class="hidden button bg-blue-500 text-white rounded-md px-2 py-1 absolute top-[-80px] left-[500px]"
                >
                Plot BER vs SNR
                </button>
               </a>


               <button
               class="button bg-blue-500 text-white rounded-md px-2 py-1 absolute top-[480px] left-[130px]"
               onclick="LTIOutput()"
             >
             LTI Output
             </button>
             <button
             class="button bg-green-500 text-white rounded-md px-2 py-1 absolute top-[-10px] left-[500px]"
             onclick="window.location.reload(true);"
           >
           Reset Simulator
           </button>

                </div>
	</div>
    <div class="middle">
        <br/><br/>
        <div class="flex flex-1 flex-col justify-center items-center">
		    <div  id = "scrolltomessage" align = "center">
            <div class="max-h-[400px] max-w-[500px]" id="transmittedSignal"></div>

			</div>
		    <div id = "scrolltocarrier" align = "center">
            <div class="max-h-[400px] max-w-[500px]" id="carrier-plot"></div>
 
			</div>
			<div id = "scrolltomodulated" align = "center">
			<div class="max-h-[400px] max-w-[500px]" id="modulated-plot"></div>
		
			</div>
		    <div id = "scrolltoimpulse" align = "center">
            <div class="max-h-[400px] max-w-[500px]" id="impulseResponse"></div>

			</div>

            <div id = "scrolltoconvolutionPlot" align = "center">
                <div class="max-h-[400px] max-w-[500px]" id="convolutionPlot"></div>
    
            </div>

		    <div id = "scrolltonoisy" align = "center">
			<div class="max-h-[400px] max-w-[500px]" id="noisy-plot"></div>

			</div>
        </div>
    </div>
    <div class="right-half hidden">
	<br/>
        <div id="berMessage"></div>
        <h2>BER vs SNR (AWGN + Rayleigh)</h2>
        <table id="resultsTable" border="1">
            <thead>
                <tr>
                    <th>SNR (dB)</th>
                    <th>BER</th>
                </tr>
            </thead>
            <tbody></tbody>
        </table>
        <div id="berVsSNR"></div>
    </div>
	    <div class="right-half-ext hidden">
		<br/>
        <div id="berMessageSingleTap"></div>
        <h2>BER vs SNR (AWGN only)(without Rayleigh</h2>
        <table id="resultsTableSingleTap" border="1">
            <thead>
                <tr>
                    <th>SNR (dB)</th>
                    <th>BER</th>
                </tr>
            </thead>
            <tbody></tbody>
        </table>
        <div id="berVsSNRSingleTap"></div>
    </div>
</div>

<div align = "center">
  <a href = ".\Effect_of_channel_qpsk_demod.html">
  <button
  class="bg-blue-500 text-white py-1 px-3  rounded-md hover:scale-105"
>
  Perform Demodulation
</button>
</a>
</div>
<!------------------------------------------------------------------------->

<div id = "demodulation">

<br/></br><br/></br>
<div>
    <h1>Instructions for BASK Demodulation Simulation (with AWGN + Rayleigh)</h1>
<ul>
    <li class="step step3">Step 1: Click 'Demodulated Signal' for demodulation</li>
    <li class="step step4">Step 2: Click 'Demodulated Signal without Rayleigh' to see the signal unaffected by Rayleigh Fading</li>
</ul>
</div>
<br/>
<div  style = "margin-left: 30px;">
<h1>BASK Demodulation Simulation (with AWGN + Rayleigh)</h1>
<br/>



<div class="container">
<div class="left-half relative">
            <br/><br/>
            <div class="w-[450px]">
              <img
                src="rayleighfading.png"
                alt="Rayleigh Fading"
                style="width: 450px; height: 400px; position: relative; left: 35px"
              />

              
            <button
              class="button bg-blue-500 text-white rounded-md px-2 py-1 relative bottom-[180px] left-[400px]"
              onclick="generateDemodulatedSignal()"
            >
              Demodulated Signal
            </button>
            <button
              class="button bg-blue-500 text-white rounded-md px-2 py-1 relative bottom-[120px] left-[235px]"
              onclick="withoutRayleigh()"
            >
            Demodulated Signal<br/>without Rayleigh
            </button>

            </div>
</div>
<div class="middle">
    <br/><br/>
    <div class="flex flex-1 flex-col justify-center items-center">
        <div id = "scrolltodemodulated" align = "center">
        <div class="max-h-[400px] max-w-[500px]" id="demodulatedSignal"></div>

        </div>
        <div id = "scrolltowithoutrayleigh" align = "center">
        <div class="max-h-[400px] max-w-[500px]" id="withoutRayleigh"></div>
        <!----
        <a href = "#top"><button>Back to Top</button></a>
        -->
        </div>
    </div>
</div>
</div>

</div>

    <script>
        let results = [];
		let resultsSingleTap = [];
        let data = [];
		let modulated_signal = [];
		let m = []; // Modulated signal
    let txSignal;
		let EbN0dB = 0;
		let excessDelay = 0;
		let h = [];
		let dataHat = [];
		let dataHatSingleTap = [];
		let upsampledSignal = [];
    let transmittedSignalTrace;

    function modulateBASK(data) {
            return data.map(bit => 2*bit -1);
        }

        function upsampleSignal(signal, U_sig) {
            const upsampledSignal = new Array(U_sig * signal.length).fill(0);
            for (let i = 0; i < signal.length; i++) {
                upsampledSignal[i * U_sig] = signal[i];
            }
            return upsampledSignal;
        }

        function generateGaussianNoise(size) {
    const noise = [];
    while (noise.length < size) {
        const u1 = Math.random();
        const u2 = Math.random();
        const z1 = Math.sqrt(-2 * Math.log(u1)) * Math.cos(2 * Math.PI * u2);
        const z2 = Math.sqrt(-2 * Math.log(u1)) * Math.sin(2 * Math.PI * u2);
        noise.push(z1, z2);
    }
    return noise.slice(0, size);
}

function addAWGN(txSignal, EbN0dB) {
    const snrLinear = Math.pow(10, EbN0dB / 10); // Assuming unit energy symbols
    const noise = generateGaussianNoise(txSignal.length);
    
    // For real-valued signals: AWGN = noise / sqrt(SNR)
    return txSignal.map((s, i) => s + (1 / Math.sqrt(snrLinear)) * noise[i]);
}


        function downsampleSignal(signal, U_sig) {
            return signal.filter((_, i) => i % U_sig === 0);
        }
        function demodulateBASK(signal) {
            return signal.map(s => s > 0 ? 1 : 0);
        }

        function calculateBER(data, dataHat) {
            const errors = data.reduce((acc, bit, i) => bit !== dataHat[i] ? acc + 1 : acc, 0);
            return errors / data.length;
        }

        function manualConv(x, h) {
            const Lx = x.length;
            const Lh = h.length;
            const y = new Array(Lx + Lh - 1).fill(0);
            for (let i = 0; i < Lx; i++) {
                for (let p = 0; p < Lh; p++) {
                    if (i + p < y.length) {
                        y[i + p] += x[i] * h[p];
                    }
                }
            }
            return y;
        }

        function expandBits(bits, repeatFactor) {
            return bits.flatMap(bit => Array(repeatFactor).fill(bit));
        }

        function updateFields() {
            const numTaps = parseInt(document.getElementById("numTaps").value) || 0;
            document.getElementById("excessDelay").value = numTaps - 1;
        }

        document.getElementById("numTaps").addEventListener("input", updateFields);

        function runSimulation1 () {
        runSimulation();
        generateASKModulatedSignal();
        }
/*
        function modulateGrayCodedQPSK(data) {
    if (data.length % 2 !== 0) {
        throw new Error("Data length should be even for QPSK modulation.");
    }

    const grayCodeMap = {
        '00': { I: -1, Q: -1 },
        '01': { I: 1, Q: -1 },
        '11': { I: 1, Q: 1 },
        '10': { I: -1, Q: 1 }
    };

    let symbols = [];
    for (let i = 0; i < data.length; i += 2) {
        // Get a 2-bit string (b1, b2)
        const bits = data.slice(i, i + 2).join('');
        const symbol = grayCodeMap[bits];
        symbols.push(symbol);
    }

    return symbols;
}


function demodulateGrayCodedQPSK(signal) {
    const grayCodeMap = {
        '00': { I: -1, Q: -1 },
        '01': { I: 1, Q: -1 },
        '11': { I: 1, Q: 1 },
        '10': { I: -1, Q: 1 }
    };

    // Reverse map to decode from symbol to bits
    const reverseGrayCodeMap = {};
    for (const bits in grayCodeMap) {
        const symbol = grayCodeMap[bits];
        reverseGrayCodeMap[`${symbol.I},${symbol.Q}`] = bits;
    }

    // Define a tolerance for comparison (e.g., allow for small floating-point discrepancies)
    const tolerance = 0.1; // Adjust this tolerance based on your system's noise characteristics

    return signal.map(s => {
        let closestMatch = null;
        let minDistance = Infinity;

        // Find the closest symbol using a tolerance for matching I, Q values
        for (const key in reverseGrayCodeMap) {
            const [I, Q] = key.split(',').map(Number);

            const distance = Math.sqrt(Math.pow(s.I - I, 2) + Math.pow(s.Q - Q, 2));

            if (distance < minDistance) {
                minDistance = distance;
                closestMatch = reverseGrayCodeMap[key];
            }
        }

        // If no match was found (which shouldn't happen with enough tolerance), default to "00"
        if (closestMatch === null) {
            console.warn('No close match found for received symbol, defaulting to "00"');
            closestMatch = '00';
        }

        // Return the bit representation of the closest symbol
        return closestMatch.split('').map(Number);
    }).flat(); // Flatten the array of bit pairs into a single array of bits
}
*/

function modulateGrayCodedQPSK(data) {
    if (data.length % 2 !== 0) {
        throw new Error("Data length should be even for QPSK modulation.");
    }

    // Gray code to decimal mapping
    const grayCodeMap = {
        '00': 0,
        '01': 1,
        '11': 2,
        '10': 3
    };

    let symbols = [];
    for (let i = 0; i < data.length; i += 2) {
        // Get a 2-bit string (b1, b2)
        const bits = data.slice(i, i + 2).join('');
        const symbol = grayCodeMap[bits];
        symbols.push(symbol); // Store the decimal symbol (0, 1, 2, 3)
    }

    return symbols;
}

// Gray-Coded QPSK Demodulation using Decimal Symbols
function demodulateGrayCodedQPSK(signal) {
    // QPSK Constellation points and their Gray codes
    const constellation = [
        { value: 0, grayCode: '00' }, // Symbol 0: (-1, -1)
        { value: 1, grayCode: '01' }, // Symbol 1: ( 1, -1)
        { value: 2, grayCode: '11' }, // Symbol 2: ( 1,  1)
        { value: 3, grayCode: '10' }  // Symbol 3: (-1,  1)
    ];

    return signal.map(symbol => {
        // Find the closest QPSK symbol (using Euclidean distance or absolute difference)
        const closestSymbol = findClosestSymbol(symbol, constellation);

        // Return the corresponding Gray code
        return closestSymbol.grayCode.split('').map(Number); // Convert Gray code to bits
    }).flat(); // Flatten the array of bit pairs into a single array of bits
}

// Helper function to find the closest symbol based on the Euclidean distance (or absolute difference)
function findClosestSymbol(receivedSymbol, constellation) {
    let minDistance = Infinity;
    let closestSymbol = null;

    // Calculate the absolute difference (Euclidean distance) between the received symbol and QPSK constellation points
    constellation.forEach(symbol => {
        const distance = Math.abs(receivedSymbol - symbol.value);

        // Find the closest symbol
        if (distance < minDistance) {
            minDistance = distance;
            closestSymbol = symbol;
        }
    });

    return closestSymbol; // Return the closest symbol
}


        function runSimulation() {
    const EbN0dB = parseFloat(document.getElementById('snr').value);
    const numTaps = parseInt(document.getElementById('numTaps').value);
    if (numTaps >= 11) {
        alert("Excess delay should be less than 10 ms as the symbol duration for QPSK is 10 ms.");
        window.location.reload(true);  
        return;
    }

    const N_total = document.getElementById('numBits').value;
    const U_sig = 10;

    // Channel Impulse Response
    const delays = Array.from({ length: numTaps }, (_, i) => i);
    h = delays.map(d => 0.8 * Math.exp(-d / (numTaps / 2)));
    h = h.map(v => v / Math.sqrt(h.reduce((acc, x) => acc + x * x, 0)));

    const unit = document.getElementById('unit').value;
    let interpolatedH = [];
    let zerosToInsert = unit === "ms" ? 1 : 9; 

    for (let i = 0; i < h.length - 1; i++) {
        interpolatedH.push(h[i]);

        for (let j = 0; j < zerosToInsert; j++) {
            interpolatedH.push(0);
        }
    }

    interpolatedH.push(h[h.length - 1]);
    h = interpolatedH;

    // Generate random binary data
    data = Array.from({ length: N_total }, () => Math.floor(Math.random() * 2));

    const upsampledtransmittedSignal = upsampleSignal(data, U_sig);

    // Gray-Coded QPSK Modulation
    const GrayCodedQPSKMod = modulateGrayCodedQPSK(data);
    
    // Upsample the Gray-coded QPSK signal
    upsampledSignal = upsampleSignal(GrayCodedQPSKMod, U_sig);

    // Transmit signal through the channel
    txSignal = manualConv(upsampledSignal, h);
    console.log("data", txSignal);
    // Generate and add AWGN noise
    const rxSignal = addAWGN(txSignal, EbN0dB);

    // Downsample to recover the original QPSK samples
    const downsampledSignal = downsampleSignal(rxSignal, U_sig);

    // Gray-Coded QPSK Demodulation
    dataHat = demodulateGrayCodedQPSK(downsampledSignal);
    const upsampleddataHat = upsampleSignal(dataHat, U_sig);
            // Calculate BER
            const berMultipath = calculateBER(data, dataHat.slice(0, N_total));
			

            // Calculate BER for single-tap channel h = 1
            const singleTapH = [1];
            const txSignalSingleTap = manualConv(upsampledSignal, singleTapH);
            const rxSignalSingleTap = addAWGN(txSignalSingleTap, EbN0dB);
            const downsampledSignalSingleTap = downsampleSignal(rxSignalSingleTap, U_sig);
            dataHatSingleTap = demodulateBASK(downsampledSignalSingleTap);
            const berSingleTap = calculateBER(data, dataHatSingleTap.slice(0, N_total));
			const upsampleddataHatSingleTap = upsampleSignal(dataHatSingleTap, U_sig);



            // Check for duplicate SNR value
            //if (results.some(result => result.snr === EbN0dB)) {
             //   alert('SNR value already exists in the table.');
            //    return;
            //}

            // Store results automatically
            results.push({ snr: EbN0dB, ber: berMultipath });

            // Sort results by SNR value
            results.sort((a, b) => a.snr - b.snr);

            // Update results table
            updateResultsTable();
			
			const message = `At SNR = ${EbN0dB} dB<br/>BER (with Rayleigh): ${berMultipath.toExponential(2)}`;

           // Update the content of the div using innerHTML
           document.getElementById('berMessage').innerHTML = message;


/*
           const transmittedSignalTrace = {
  x: Array.from({ length: 10 }, (_, i) => i / 100).flatMap(i => [i, i, null]),
  y: data.slice(0, 10).flatMap(y => [0, y, null]),
  mode: 'lines',
  line: { color: 'blue', width: 4 },
  type: 'scatter',
  name: 'Bit Stream'
};

const annotations = data.slice(0, 10).map((bit, index) => ({
  x: index * (1 / 100),
  y: 1.1,
  text: bit.toString(),
  showarrow: false,
  font: { color: "black", size: 14 }
}));

Plotly.newPlot('transmittedSignal', [transmittedSignalTrace],  {
  title: "Original BASK Message Signal",
  xaxis: { title: 'Time (s)' },
  yaxis: { title: 'Amplitude' },
  annotations: annotations
});
*/

// Number of bits to plot
const bitsToPlot = 10;

// Time per bit (adjust as needed for spacing)
const bitDuration = 1 / 100; // e.g., 0.1 seconds per bit

// Generate time and value arrays for step-like pulse
const x = [];
const y = [];

for (let i = 0; i < bitsToPlot; i++) {
    const t0 = i * bitDuration;
    const t1 = (i + 1) * bitDuration;
    const bit = data[i];

    x.push(t0, t1);
    y.push(bit, bit);
}

// Create trace for digital pulse waveform
transmittedSignalTrace = {
    x: x,
    y: y,
    mode: 'lines',
    line: { color: 'blue', width: 2 },
    type: 'scatter',
    name: 'Original Message Signal'
};

// Annotations for each bit
const annotations = data.slice(0, bitsToPlot).map((bit, index) => ({
    x: index * bitDuration + bitDuration / 2,
    y: 1.1,
    text: bit.toString(),
    showarrow: false,
    font: { color: "black", size: 14 }
}));

// Plot using Plotly
Plotly.newPlot('transmittedSignal', [transmittedSignalTrace], {
    title: "Original Message Signal",
    xaxis: { title: 'Time (s)', range: [0, bitsToPlot * bitDuration] },
    yaxis: { title: 'Amplitude' },
    annotations: annotations
});


			// Scroll to the plot area
		    document.getElementById('scrolltomessage').style.display = 'block';
            document.getElementById('scrolltomessage').scrollIntoView({ behavior: 'smooth' });
            //const repeatFactor = 10;
            //const demodulatedSignalExpanded = expandBits(dataHat.slice(0, 100), repeatFactor);
            //const demodulatedSignalScaled = demodulatedSignalExpanded.map(bit => bit);
            
///////////////////////////////////////
function updateResultsTableSingleTap() {
    const tableBody = document.getElementById('resultsTableSingleTap').getElementsByTagName('tbody')[0];
    tableBody.innerHTML = ''; // Clear existing rows

    resultsSingleTap.forEach(result => {
        const row = tableBody.insertRow();
        row.insertCell(0).innerText = result.snr;
        row.insertCell(1).innerText = result.ber.toExponential(2);
    });

}



// Store results automatically
resultsSingleTap.push({ snr: EbN0dB, ber: berSingleTap });

// Sort results by SNR value
resultsSingleTap.sort((a, b) => a.snr - b.snr);

updateResultsTableSingleTap();
			const messageSingleTap = `At SNR = ${EbN0dB} dB<br>BER (without Rayleigh): ${berSingleTap.toExponential(2)}`;

           // Update the content of the div using innerHTML
           document.getElementById('berMessageSingleTap').innerHTML = messageSingleTap;

//////////////////////////////////////////
/////////////////////////////////////////
}

function plotBERvsSNRSingleTap() {
    if (resultsSingleTap.length === 0) {
        alert('No results to plot.');
        return;
    }

    const snrValues = resultsSingleTap.map(result => result.snr);
    const berValues = resultsSingleTap.map(result => result.ber);

    const trace = {
        x: snrValues,
        y: berValues,
        mode: 'markers+lines',
        type: 'scatter',
        marker: { color: 'blue' }
    };

    const layout = {
        title: 'BER vs. SNR (AWGN only)',
        xaxis: { title: 'SNR (dB)' },
        yaxis: { title: 'BER', type: 'log' }
    };

    Plotly.newPlot('berVsSNRSingleTap', [trace], layout);
}


        function updateResultsTable() {
            const tableBody = document.getElementById('resultsTable').getElementsByTagName('tbody')[0];
            tableBody.innerHTML = ''; // Clear existing rows

            results.forEach(result => {
                const row = tableBody.insertRow();
                row.insertCell(0).innerText = result.snr;
                row.insertCell(1).innerText = result.ber.toExponential(2);
            });
        }

        function plotBERvsSNR() {
            if (results.length === 0) {
                alert('No results to plot.');
                return;
            }

            const snrValues = results.map(result => result.snr);
            const berValues = results.map(result => result.ber);

            const trace = {
                x: snrValues,
                y: berValues,
                mode: 'markers+lines',
                type: 'scatter',
                marker: { color: 'blue' }
            };

            const layout = {
                title: 'BER vs. SNR (AWGN + Rayleigh)',
                xaxis: { title: 'SNR (dB)' },
                yaxis: { title: 'BER', 
				type: 'log'
				},
				
            };

            Plotly.newPlot('berVsSNR', [trace], layout);
			plotBERvsSNRSingleTap();
        }
		
				    function generateCarrierSignal() {
            Fs = 1000;
            fc = 20;
            const t = Array.from({ length: 1 * Fs }, (_, i) => i / Fs);
            const carrier_signal = t.map((time) => Math.sin(2 * Math.PI * fc * time));

            const carrierData = [{
                x: t,
                y: carrier_signal,
                type: "scatter",
                mode: "lines",
                name: "Carrier Signal",
            }];

            const carrierLayout = {
                title: "Carrier Signal (20 Hz)",
                xaxis: { title: "Time (s)" },
                yaxis: { title: "Amplitude" },
            };

            Plotly.newPlot("carrier-plot", carrierData, carrierLayout);
						// Scroll to the plot area

			document.getElementById('scrolltocarrier').style.display = 'block';
			            document.getElementById('scrolltocarrier').scrollIntoView({ behavior: 'smooth' });
        }
		
		
		function generateASKModulatedSignal1() {
		        const BASKSignalTrace = {
                x: Array.from({ length: 100 * 10 }, (_, i) => i / 10 / 100),
                y: upsampledSignal.slice(0, 100 * 10),
                mode: 'lines',
                type: 'scatter'
            };
            Plotly.newPlot('modulated-plot1', [BASKSignalTrace], {
                xaxis: { title: 'Time (s)' },
                yaxis: { title: 'Amplitude' }
            });
			
		}
		
function generateASKModulatedSignal() {
    const fs = 1000; // Sampling frequency
    const f = document.getElementById('carrierFrequency').value / 100;
    const bp = 1/100; // Bit period (seconds)
    
    const messageSignal = data.slice(0, 10); // Assuming data is defined elsewhere
    const bit = messageSignal; // Use messageSignal directly if it represents the bit values
    
    const t1 = []; // Time array for the modulated signal
    for (let i = 0; i < fs * (bit.length / 2); i++) {
        t1.push((i / fs) * bp); // Time array for each symbol period (2 bits per symbol in QPSK)
    }
    
    const A = 1; // Amplitude for QPSK symbols
    
    modulated_signal = []; // Initialize modulated signal array
    
    // Gray coding map for QPSK
    const grayCodeMap = {
        '00': { phase: 0 },   // 0° phase shift
        '01': { phase: Math.PI / 2 },  // 90° phase shift
        '11': { phase: Math.PI },  // 180° phase shift
        '10': { phase: 3 * Math.PI / 2 }  // 270° phase shift
    };
    
    // Process the data in pairs of bits for QPSK
    for (let i = 0; i < bit.length; i += 2) {
        // Create a time array for one symbol period (2 bits)
        const t2 = Array.from({ length: fs }, (_, k) => k / fs);
        
        // Modulate based on the Gray coded pair of bits
        const bitPair = bit.slice(i, i + 2).join('');
        let y = [];
        
        // Get the phase corresponding to the Gray code for the current bit pair
        const phase = grayCodeMap[bitPair].phase;

        // Apply the phase shift to the signal (cosine or sine depending on the phase)
        y = t2.map(t => A * Math.cos(2 * Math.PI * f * t + phase)); // Apply the phase shift
        
        modulated_signal = modulated_signal.concat(y); // Concatenate each symbol's signal
    }
    
    // Prepare data for plotting
    const modulatedData = [
        {
            x: t1,
            y: modulated_signal,
            type: "scatter",
            mode: "lines",
            name: "Gray Coded QPSK Modulated Signal",
            line: { color: "blue" },
        },
    ];
    
    // Plot the Gray coded QPSK modulated signal
    Plotly.newPlot("modulated-plot", modulatedData, {
        title: "Gray Coded QPSK Modulated Signal",
    });
    
    // Scroll to the plot area
    document.getElementById('scrolltomodulated').style.display = 'block';
    document.getElementById('scrolltomodulated').scrollIntoView({ behavior: 'smooth' });
}



		
		function generateChannelImpulseResponse() {
		            // Display impulse response and other plots
            const impulseResponseTrace = {
                x: h.flatMap((_, i) => [i/1000, i/1000, null]),
                y: h.flatMap(y => [0, y, null]),
                mode: 'lines',
                line: { color: 'blue', width: 4 },
                type: 'scatter'
            };

            const layout = {
			    title: "Channel Impulse Response",
                xaxis: { title: 'Time (s)' },
                yaxis: { title: 'Channel Gain' }
            };

            Plotly.newPlot('impulseResponse', [impulseResponseTrace], layout);
						// Scroll to the plot area

            document.getElementById('scrolltoimpulse').style.display = 'block';
            document.getElementById('scrolltoimpulse').scrollIntoView({ behavior: 'smooth' });
			}
			
			function generateDemodulatedSignal() {    
            const demodulatedSignalTrace = {
                x: Array.from({ length: 100 }, (_, i) => i/100).flatMap(i => [i, i, null]),
                y: dataHat.slice(0, 10).flatMap(y => [0, y, null]),
                mode: 'lines',
	            line: { color: 'blue', width: 4 },
                type: 'scatter'
            };

            const annotations = dataHat.slice(0, 10).map((bit, index) => ({
            x: index * (1 / 100),  // center of the pulse
            y: 1.1,                      // a little above the bit value
            text: bit.toString(),
            showarrow: false,
            font: { color: "black", size: 14 }
            }));

            Plotly.newPlot('demodulatedSignal', [demodulatedSignalTrace], {
			    title : "Demodulated Message Signal",
                xaxis: { title: 'Bit Index' },
                yaxis: { title: 'Amplitude' },
                annotations: annotations
            });
						// Scroll to the plot area

			document.getElementById('scrolltodemodulated').style.display = 'block';
			           document.getElementById('scrolltodemodulated').scrollIntoView({ behavior: 'smooth' });
			}
			
	    function withoutRayleigh() {	
			const withoutRayleighTrace = {
			    
                x: Array.from({ length: 100 }, (_, i) => i / 100).flatMap(i => [i, i, null]),
                y: dataHatSingleTap.slice(0, 10).flatMap(y => [0, y, null]),
                mode: 'lines',
			    line: { color: 'blue', width: 4 },
                type: 'scatter'
            };
            const annotations = dataHatSingleTap.slice(0, 10).map((bit, index) => ({
            x: index * (1 / 100),  // center of the pulse
            y: 1.1,                      // a little above the bit value
            text: bit.toString(),
            showarrow: false,
            font: { color: "black", size: 14 }
            }));
            Plotly.newPlot('withoutRayleigh', [withoutRayleighTrace], {
			    title : "Demodulated Message Signal (without Rayleigh)",
                xaxis: { title: 'Time (s)' },
                yaxis: { title: 'Amplitude' },
                annotations: annotations
            });
						// Scroll to the plot area
									document.getElementById('scrolltowithoutrayleigh').style.display = 'block';
            document.getElementById('scrolltowithoutrayleigh').scrollIntoView({ behavior: 'smooth' });

			}
			
		    function generateNoisySignal() {
		    const Fs = 1000;
			const EbN0dB = parseFloat(document.getElementById('snr').value);
            const noisy_signal = addAWGN(convSignal, EbN0dB);
            const NoisySignal = [{
                x: Array.from({ length: noisy_signal.length }, (_, i) => (i / Fs/10)),
                y: noisy_signal.slice(0,1000),
                type: "scatter",
                mode: "lines",
                name: "Carrier Signal",
            }];

            const NoisySignalLayout = {
                title: "Noisy Signal",
                xaxis: { title: "Time (s)" },
                yaxis: { title: "Amplitude" },
            };

            Plotly.newPlot("noisy-plot", NoisySignal, NoisySignalLayout);
						// Scroll to the plot area

			document.getElementById('scrolltonoisy').style.display = 'block';
			            document.getElementById('scrolltonoisy').scrollIntoView({ behavior: 'smooth' });
        }

    
        let convSignal, convolvedSignalTrace;
function LTIOutput() {
    const Fs = 1000;  // Sampling frequency in Hz
    const dt = 1 / Fs; // Time step in seconds

    // Ensure modulated_signal is defined globally or passed in
    convSignal = manualConv(modulated_signal, h);

    // Generate time vector in seconds for plotting
    const timeVector = Array.from({ length: convSignal.length }, (_, i) => (i * dt/100));  // in seconds

    convolvedSignalTrace = [{
        x: timeVector,
        y: convSignal,
        type: "scatter",
        mode: "lines",
        name: "Channel Output",
        line: { color: 'green', width: 2 }
    }];

    Plotly.newPlot('convolutionPlot', convolvedSignalTrace, {
        title: 'Output after Convolution with Channel',
        xaxis: { title: 'Time (s)' },  // changed from 'Time (ms)' to 'Time (s)'
        yaxis: { title: 'Amplitude' }
    });

    // Scroll to the plot smoothly
    document.getElementById('scrolltoconvolutionPlot').scrollIntoView({ behavior: 'smooth' });
}



let NoisySignalTrace;
function generateNoisySignalff() {
    const Fs = 1000;   // Sampling frequency in Hz
    const dt = 1 / Fs; // Time step in seconds

    // Generate time vector in seconds (instead of milliseconds)
    const timeVector = Array.from({ length: convSignal.length }, (_, i) => i * dt/100);  // in seconds

    const EbN0dB = parseFloat(document.getElementById('snr').value);
    const noisy_signal = addAWGN(convSignal, EbN0dB);

    NoisySignalTrace = {
        x: timeVector,
        y: noisy_signal,
        type: "scatter",
        mode: "lines",
        name: "Received Signal",
        line: { color: 'red', width: 2 }
    };

    const NoisySignalLayout = {
        title: "Noisy Signal",
        xaxis: { title: "Time (s)" },  // Changed ms to s here
        yaxis: { title: "Amplitude" }
    };

    Plotly.newPlot('noisy-plot', [NoisySignalTrace], NoisySignalLayout);

    // Scroll to the plot area
    const scrollTarget = document.getElementById('scrolltonoisy');
    if (scrollTarget) {
        scrollTarget.style.display = 'block';
        scrollTarget.scrollIntoView({ behavior: 'smooth' });
    }

    // Save data if needed
    saveData();
}



        function saveData() {

// Store as an object (use the variables you actually defined)
const myData = { dataHat: dataHat, dataHatSingleTap: dataHatSingleTap, NoisySignalTrace: NoisySignalTrace, transmittedSignalTrace:transmittedSignalTrace };

console.log(myData);
localStorage.setItem('sharedData', JSON.stringify(myData));
}

    </script>
		    <style>

          #demodulation {
            display: none;
          }
		/* Style for input field */
input {
  margin-left: 10px; /* max-lg:ml-10 equivalent */
  border: 1px solid black; /* border border-black */
  padding: 0.25rem 0.5rem; /* px-2 py-1 */
  border-radius: 0.125rem; /* rounded-sm */
}

/* Style for button */
button {
  background-color: #3B82F6; /* bg-blue-500 */
  color: white; /* text-white */
  border-radius: 0.375rem; /* rounded-md */
  padding: 0.25rem 0.5rem; /* px-2 py-1 */
}
h2,.custom-text {
  color: #2c99ce; /* text-[#2c99ce] */
  font-weight: 1000; /* font-medium */
}

#scrolltomessage, #scrolltocarrier, #scrolltomodulated, #scrolltoimpulse, #scrolltonoisy,
#scrolltodemodulated, #scrolltowithoutrayleigh {
display: none;
}

#container {
  background-color: #fff;
  box-shadow: 0 4px 12px rgba(0, 0, 0, 0.15);
  border-radius: 12px;
  padding: 25px 40px;
  max-width: 100%;
  margin: 20px auto;
  text-align: left;
  font-family: 'Segoe UI', sans-serif;
}

h1 {
  color: #1e3a8a;
  font-size: 24px;
  margin-bottom: 25px;
  text-align: justify;
}

ul {
  list-style-type: none;
  padding: 0;
  margin: 0;
}

li.step {
  margin: 12px 0;
  padding: 12px 15px;
  border-radius: 6px;
  font-size: 17px;
  font-weight: 500;
  box-shadow: 0 2px 6px rgba(0, 0, 0, 0.05);
  transition: transform 0.2s ease, background-color 0.2s ease;
}

li.step::before {
  content: "✔";
  color: #10b981;
  margin-right: 10px;
  font-weight: bold;
}

li.step:hover {
  transform: scale(1.02);
  background-color: #f3f4f6;
}

/* Color code each step */
.step1 {
  background-color: #ffe0e0;
  border-left: 5px solid #ef4444;
}
.step2 {
  background-color: #e0f7ff;
  border-left: 5px solid #0ea5e9;
}
.step3 {
  background-color: #e0ffe5;
  border-left: 5px solid #22c55e;
}
.step4 {
  background-color: #f5e0ff;
  border-left: 5px solid #a855f7;
}
	</style>
</body>
</html>
